package data_structure_and_algorithm.graph;

/**
 * 图 - 图是一种较线性表和树更为复杂的数据结构：
 *      *在线性表中，数据元素之间仅有线性关系，
 *      *在树形结构中，数据元素之间有着明显的层次关系，
 *      *而在图形结构中，节点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。
 *
 *      图的应用相当广泛，特别是近年来的迅速发展，已经渗入到诸如语言学、逻辑学、物理、化学、电讯工程、计算机科学以及数学的其他分支中。
 *
 *
 *  【深度优先遍历算法】DFS - Depth First Search - 递归思想！
 *      *类似树的先序遍历
 *      *其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。
 *      *需要栈的辅助
 *
 *  【广度优先遍历算法】BFS - Breadth First Search
 *      *类似树的层次遍历
 *      *简单描述为：从点v开始一次访问其所有临接点，然后遍历其邻接点，继续遍历其每个邻接点的邻接点！
 *      *始终保证一点：如果vi在vk之前被访问，则vi的邻接点应在vk的邻接点之前被访问。
 *      *需要队列的辅助
 *
 *
 *  【最小生成树】 - 普利姆Prim算法、克鲁斯卡尔Kruskal算法！
 *
 *      *Prim算法 - 适合边稠密的图
 *          *思路：首先就是从图中的一个起点a开始，把a加入U集合，然后，寻找从与a有关联的边中，权重最小的那条边
 *                并且该边的终点b在顶点集合：（V-U）中，我们也把b加入到集合U中，并且输出边（a，b）的信息，
 *                这样我们的集合U就有：{a,b}，然后，我们寻找与a关联和b关联的边中，权重最小的那条边并且该边的
 *                终点在集合：（V-U）中，我们把c加入到集合U中，并且输出对应的那条边的信息，这样我们的集合U就
 *                有：{a,b,c}这三个元素了，一次类推，直到所有顶点都加入到了集合U。
 *
 *      *Kruskal算法 - 适合边稀疏的图
 *          算法思路：
 *          （1）将图中的所有边都去掉。
 *          （2）将边按权值从小到大的顺序添加到图中，保证添加的过程中不会形成环
 *          （3）重复上一步直到连接所有顶点，此时就生成了最小生成树。
 *          这是一种贪心策略。
 *
 *
 *  【最短路径】 - TODO 迪杰斯特拉算法、弗洛伊德算法！
 *
 *
 */
public class Graph {



}
